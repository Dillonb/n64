#include <cpu/dynarec/v2/v2_emitter.h>
#include <cpu/dynarec/v2/v2_compiler.h>
#include <cpu/dynarec/v2/ir_optimizer.h>
#include <cpu/dynarec/v2/target_platform.h>
#include <cpu/dynarec/dynarec_memory_management.h>
#include <cpu/r4300i.h>

#include <dynasm/dasm_proto.h>
#ifndef N64_WIN
#include <sys/mman.h>
#endif

#define IMM64_INVALID() logfatal("Should never end up here, x86_64 has no 64 bit immediates")

||#if ((defined(_M_X64) || defined(__amd64__)) != X64) || (defined(_WIN32) != WIN)
#error "Wrong DynASM flags used: pass `-D X64` and/or `-D WIN` to dynasm.lua as appropriate"
#endif

|.if X64
|.arch x64
|.else
|#error "Only x64 is supported"
|.endif

|.if X64
  |.define cpuState, rax // TODO: put this in a more permanent reg?
  |.if WIN
    |.define rArg1, rcx
    |.define rArg2, rdx
  |.else
    |.define rArg1, rdi
    |.define rArg2, rsi
  |.endif
  |.macro prepcall1, arg1
    | mov rArg1, arg1
  |.endmacro
  |.macro prepcall2, arg1, arg2
    | mov rArg1, arg1
    | mov rArg2, arg2
  |.endmacro
  |.define postcall, .nop
    // Called before our block
    |.macro prologue
    |.endmacro
    // Called at the end of our block
    |.macro epilogue
      | ret
    |.endmacro
|.endif // TODO ARM version?
|.type cpu_state, r4300i_t, cpuState
|.type rsp_state, rsp_t, cpuState

dasm_State* v2_block_header() {
    dasm_State* d;
    unsigned npc = 8; // number of dynamic labels

    |.section code
    dasm_init(&d, DASM_MAXSECTION);

    |.globals lbl_

    void* labels[lbl__MAX];
    dasm_setupglobal(&d, labels, lbl__MAX);

    |.actionlist actions
    dasm_setup(&d, actions);
    dasm_growpc(&d, npc);

    dasm_State** Dst = &d;
    |.code
    |->compiled_block:
    | prologue
    return d;
}

const char* reg_names[] = {
        "rax",
        "rcx",
        "rdx",
        "rbx",
        "rsp",
        "rbp",
        "rsi",
        "rdi",
        "r8",
        "r9",
        "r10",
        "r11",
        "r12",
        "r13",
        "r14",
        "r15",
};


void host_emit_mov_reg_imm(dasm_State** Dst, int reg, ir_set_constant_t imm_value) {
    u64 value = set_const_to_u64(imm_value);
    if (imm_value.type == VALUE_TYPE_64) {
        | mov64 Rq(reg), value
    } else {
        // DynASM will automatically detect sign extension here, and use the smallest possible immediate
        | mov Rq(reg), value
    }
}

void host_emit_and_reg_imm(dasm_State** Dst, int reg, ir_set_constant_t imm_value) {
    switch (imm_value.type) {
        case VALUE_TYPE_S8:
            | and Rq(reg), imm_value.value_s8
            break;
        case VALUE_TYPE_U8:
            | and Rq(reg), imm_value.value_s8
            break;
        case VALUE_TYPE_S16:
            | and Rq(reg), imm_value.value_s16
            break;
        case VALUE_TYPE_U16:
            | and Rq(reg), imm_value.value_s16
            break;
        case VALUE_TYPE_S32:
            | and Rq(reg), imm_value.value_s32
            break;
        case VALUE_TYPE_U32:
            | and Rq(reg), imm_value.value_u32
            break;
        case VALUE_TYPE_64:
            IMM64_INVALID();
            break;
    }
}

void host_emit_add_reg_imm(dasm_State** Dst, int reg, ir_set_constant_t imm_value) {
    switch (imm_value.type) {
        case VALUE_TYPE_S8:
            | add Rq(reg), imm_value.value_s8
            break;
        case VALUE_TYPE_U8:
            | add Rq(reg), imm_value.value_s8
            break;
        case VALUE_TYPE_S16:
            | add Rq(reg), imm_value.value_s16
            break;
        case VALUE_TYPE_U16:
            | add Rq(reg), imm_value.value_s16
            break;
        case VALUE_TYPE_S32:
            | add Rq(reg), imm_value.value_s32
            break;
        case VALUE_TYPE_U32:
            | add Rq(reg), imm_value.value_u32
            break;
        case VALUE_TYPE_64:
            IMM64_INVALID();
            break;
    }
}

void host_emit_shift_reg_imm(dasm_State** Dst, int reg, ir_value_type_t type, u8 shift_amount, ir_shift_direction_t direction) {
   switch (type) {
       case VALUE_TYPE_S8:
       case VALUE_TYPE_U8:
           logfatal("Shift 8 bit value");
           break;
       case VALUE_TYPE_S16:
       case VALUE_TYPE_U16:
           logfatal("Shift 16 bit value");
           break;

       case VALUE_TYPE_S32:
           switch (direction) {
               case SHIFT_DIRECTION_LEFT:
                   | sal Rd(reg), shift_amount
                   break;
               case SHIFT_DIRECTION_RIGHT:
                   | sar Rd(reg), shift_amount
                   break;
           }
           break;

       case VALUE_TYPE_U32:
           switch (direction) {
               case SHIFT_DIRECTION_LEFT:
                   | shl Rd(reg), shift_amount
                   break;
               case SHIFT_DIRECTION_RIGHT:
                   | shr Rd(reg), shift_amount
                   break;
           }
           break;

       case VALUE_TYPE_64:
           switch (direction) {
               case SHIFT_DIRECTION_LEFT:
                   logfatal("shl 64");
                   break;
               case SHIFT_DIRECTION_RIGHT:
                   logfatal("shr 64");
                   break;
           }
           break;
   }
}

void host_emit_mov_reg_reg(dasm_State** Dst, int dst_reg, int src_reg, ir_value_type_t source_value_type) {
    if (source_value_type == VALUE_TYPE_64 && dst_reg == src_reg) {
        return;
    }
    switch (source_value_type) {
        case VALUE_TYPE_S8:
            | movsx Rq(dst_reg), Rb(src_reg)
            break;
        case VALUE_TYPE_U8:
            | movzx Rq(dst_reg), Rb(src_reg)
            break;
        case VALUE_TYPE_S16:
            | movsx Rq(dst_reg), Rw(src_reg)
            break;
        case VALUE_TYPE_U16:
            | movzx Rq(dst_reg), Rw(src_reg)
            break;
        case VALUE_TYPE_S32:
            | movsxd Rq(dst_reg), Rd(src_reg)
            break;
        case VALUE_TYPE_U32:
            // Writing to a 32 bit reg zero extends to the 64 bit reg
            | mov Rd(dst_reg), Rd(src_reg)
            break;
        case VALUE_TYPE_64:
            | mov Rq(dst_reg), Rq(src_reg)
            break;
    }
}

void host_emit_call(dasm_State** Dst, uintptr_t function) {
    | mov64 rax, function
    | call rax
}

void set_dest_cond(dasm_State** Dst, int dest_reg, ir_condition_t cond, enum args_reversed args_reversed) {
    if (dest_reg >= 0) {
        switch (cond) {
            case CONDITION_NOT_EQUAL:
                | setne Rb(dest_reg)
                break;
            case CONDITION_EQUAL:
                | sete Rb(dest_reg)
                break;
            case CONDITION_LESS_THAN:
                if (args_reversed) {
                    | setge Rb(dest_reg)
                } else {
                    | setl Rb(dest_reg)
                }

        }
    }
}

void host_emit_cmp_reg_imm(dasm_State** Dst, int dest_reg, ir_condition_t cond, int operand1, ir_set_constant_t operand2, enum args_reversed args_reversed) {
    switch (operand2.type) {
        case VALUE_TYPE_S8:
            | cmp Rq(operand1), operand2.value_s8
            break;
        case VALUE_TYPE_U8:
            | cmp Rq(operand1), operand2.value_s8
            break;
        case VALUE_TYPE_S16:
            | cmp Rq(operand1), operand2.value_s16
            break;
        case VALUE_TYPE_U16:
            | cmp Rq(operand1), operand2.value_s16
            break;
        case VALUE_TYPE_S32:
            | cmp Rq(operand1), operand2.value_s32
            break;
        case VALUE_TYPE_U32:
            | cmp Rq(operand1), operand2.value_u32
            break;
        case VALUE_TYPE_64:
            IMM64_INVALID();
            break;
    }
    set_dest_cond(Dst, dest_reg, cond, args_reversed);
}

void host_emit_cmp_reg_reg(dasm_State** Dst, int dest_reg, ir_condition_t cond, int operand1, int operand2, enum args_reversed args_reversed) {
    | cmp Rq(operand1), Rq(operand2)
    set_dest_cond(Dst, dest_reg, cond, args_reversed);
}

void host_emit_mov_pc(dasm_State** Dst, ir_instruction_t* value) {
    uintptr_t n64_cpu_addr = (uintptr_t)&N64CPU;
    | mov64 rax, n64_cpu_addr
    if (is_constant(value)) {
        u64 const_value = const_to_u64(value);
        | mov64 rdi, const_value
        | mov cpu_state->pc, rdi
        | add rdi, 4
        | mov cpu_state->next_pc, rdi
    } else {
        | mov rdi, Rq(value->allocated_host_register)
        | mov cpu_state->pc, rdi
        | add rdi, 4
        | mov cpu_state->next_pc, rdi
    }
}

void host_emit_cmov_pc_binary(dasm_State** Dst, int cond_register, ir_instruction_t* if_true, ir_instruction_t* if_false) {
    | test Rb(cond_register), Rb(cond_register)
    | jz >1
    host_emit_mov_pc(Dst, if_true);
    | jmp >2 // done
    |1:
    host_emit_mov_pc(Dst, if_false);
    |2:
}

void host_emit_mov_mem_imm(dasm_State** Dst, uintptr_t mem, ir_set_constant_t value) {
    int tmp1 = get_scratch_registers()[0];
    int tmp2 = get_scratch_registers()[1];

    | mov64 Rq(tmp1), mem
    host_emit_mov_reg_imm(Dst, tmp2, value);
    |mov [Rq(tmp1)], Rq(tmp2)
}

void host_emit_mov_mem_reg(dasm_State** Dst, uintptr_t mem, int reg) {
    | mov64 rax, mem
    | mov [rax], Rq(reg)
}

void host_emit_mov_reg_mem(dasm_State** Dst, int reg, uintptr_t mem) {
    | mov64 rax, mem
    | mov Rq(reg), [rax]
}

void v2_end_block(dasm_State** Dst, int block_length) {
    | mov eax, block_length
    | epilogue // return block_length
}