#include <cpu/dynarec.h>

#include <dynasm/dasm_proto.h>
#include <dynasm/dasm_x86.h>
#include <sys/mman.h>

#include <mem/n64bus.h>
#include "mips_instructions.h"

||#if ((defined(_M_X64) || defined(__amd64__)) != X64) || (defined(_WIN32) != WIN)
#error "Wrong DynASM flags used: pass `-D X64` and/or `-D WIN` to dynasm.lua as appropriate"
#endif

|.if X64
|.arch x64
|.else
|.arch x86
|.endif

|.if X64
  |.define cpuState, r12
  |.define instrArg, r13
  |.if WIN
    |.define rArg1, rcx
    |.define rArg2, rdx
  |.else
    |.define rArg1, rdi
    |.define rArg2, rsi
  |.endif
  |.macro prepcall2, arg1, arg2
    | mov rArg1, arg1
    | mov rArg2, arg2
  |.endmacro
  |.define postcall, .nop
    // Called before our block
    |.macro prologue
      // Push callee-saved registers onto the stack so we don't trample them
      | push cpuState
      | push instrArg
      | push rax
      // The CPU's state is passed in as argument 1
      | mov cpuState, rArg1
    |.endmacro
    // Called at the end of our block
    |.macro epilogue
      // Pop callee-saved registers off the stack and then return
      | pop rax
      | pop instrArg
      | pop cpuState
      | ret
    |.endmacro
|.endif // TODO x86 version? ARM version?





void* bumpalloc(n64_dynarec_t* dynarec, size_t size) {
    if (dynarec->codecache_used + size >= dynarec->codecache_size) {
        logfatal("Exhausted code cache!");
    }

    void* ptr = &dynarec->codecache[dynarec->codecache_used];

    dynarec->codecache_used += size;

    printf("bumpalloc: %ld used of %ld\n", dynarec->codecache_used, dynarec->codecache_size);

    return ptr;
}

void* bumpalloc_zero(n64_dynarec_t* dynarec, size_t size) {
    byte* ptr = bumpalloc(dynarec, size);

    for (int i = 0; i < size; i++) {
        ptr[i] = 0;
    }

    return ptr;
}

void* link_and_encode(n64_dynarec_t* dynarec, dasm_State** d) {
    size_t code_size;
    dasm_link(d, &code_size);
    printf("Generated %ld bytes of code\n", code_size);
    void* buf = bumpalloc(dynarec, code_size);
    dasm_encode(d, buf);

    return buf;
}

#define COMPILER(name) bool name(dasm_State** Dst, mips_instruction_t instr, word address)

COMPILER(compile_mips_nop) {
    return false;
}

COMPILER(compile_mips_ld) {
    uintptr_t handler = (uintptr_t)mips_ld;
    | prepcall2 cpuState, instr
    // x86_64 cannot call a 64 bit immediate, put it into rax first
    | mov64 rax, handler
    | call rax
    | postcall 2
    return false;
}

COMPILER(compile_mips_lui) {
    uintptr_t handler = (uintptr_t)mips_lui;
    | prepcall2 cpuState, instr
    // x86_64 cannot call a 64 bit immediate, put it into rax first
    | mov64 rax, handler
    | call rax
    | postcall 2
    return false;
}

COMPILER(compile_mips_addiu) {
    uintptr_t handler = (uintptr_t)mips_addiu;
    | prepcall2 cpuState, instr
    // x86_64 cannot call a 64 bit immediate, put it into rax first
    | mov64 rax, handler
    | call rax
    | postcall 2
    return false;
}

COMPILER(compile_mips_addi) {
    uintptr_t handler = (uintptr_t)mips_addi;
    | prepcall2 cpuState, instr
    // x86_64 cannot call a 64 bit immediate, put it into rax first
    | mov64 rax, handler
    | call rax
    | postcall 2
    return false;
}

COMPILER(compile_mips_daddi) {
    uintptr_t handler = (uintptr_t)mips_daddi;
    | prepcall2 cpuState, instr
    // x86_64 cannot call a 64 bit immediate, put it into rax first
    | mov64 rax, handler
    | call rax
    | postcall 2
    return false;
}

COMPILER(compile_mips_andi) {
    uintptr_t handler = (uintptr_t)mips_andi;
    | prepcall2 cpuState, instr
    // x86_64 cannot call a 64 bit immediate, put it into rax first
    | mov64 rax, handler
    | call rax
    | postcall 2
    return false;
}

COMPILER(compile_mips_lbu) {
    uintptr_t handler = (uintptr_t)mips_lbu;
    | prepcall2 cpuState, instr
    // x86_64 cannot call a 64 bit immediate, put it into rax first
    | mov64 rax, handler
    | call rax
    | postcall 2
    return false;
}

COMPILER(compile_mips_lhu) {
    uintptr_t handler = (uintptr_t)mips_lhu;
    | prepcall2 cpuState, instr
    // x86_64 cannot call a 64 bit immediate, put it into rax first
    | mov64 rax, handler
    | call rax
    | postcall 2
    return false;
}

COMPILER(compile_mips_lh) {
    uintptr_t handler = (uintptr_t)mips_lh;
    | prepcall2 cpuState, instr
    // x86_64 cannot call a 64 bit immediate, put it into rax first
    | mov64 rax, handler
    | call rax
    | postcall 2
    return false;
}

COMPILER(compile_mips_lw) {
    uintptr_t handler = (uintptr_t)mips_lw;
    | prepcall2 cpuState, instr
    // x86_64 cannot call a 64 bit immediate, put it into rax first
    | mov64 rax, handler
    | call rax
    | postcall 2
    return false;
}

COMPILER(compile_mips_lwu) {
    uintptr_t handler = (uintptr_t)mips_lwu;
    | prepcall2 cpuState, instr
    // x86_64 cannot call a 64 bit immediate, put it into rax first
    | mov64 rax, handler
    | call rax
    | postcall 2
    return false;
}

COMPILER(compile_mips_beq) {
    uintptr_t handler = (uintptr_t)mips_beq;
    | prepcall2 cpuState, instr
    // x86_64 cannot call a 64 bit immediate, put it into rax first
    | mov64 rax, handler
    | call rax
    | postcall 2
    return true;
}

COMPILER(compile_mips_beql) {
    uintptr_t handler = (uintptr_t)mips_beql;
    | prepcall2 cpuState, instr
    // x86_64 cannot call a 64 bit immediate, put it into rax first
    | mov64 rax, handler
    | call rax
    | postcall 2
    return true;
}

COMPILER(compile_mips_bgtz) {
    uintptr_t handler = (uintptr_t)mips_bgtz;
    | prepcall2 cpuState, instr
    // x86_64 cannot call a 64 bit immediate, put it into rax first
    | mov64 rax, handler
    | call rax
    | postcall 2
    return true;
}

COMPILER(compile_mips_bgtzl) {
    uintptr_t handler = (uintptr_t)mips_bgtzl;
    | prepcall2 cpuState, instr
    // x86_64 cannot call a 64 bit immediate, put it into rax first
    | mov64 rax, handler
    | call rax
    | postcall 2
    return true;
}

COMPILER(compile_mips_blez) {
    uintptr_t handler = (uintptr_t)mips_blez;
    | prepcall2 cpuState, instr
    // x86_64 cannot call a 64 bit immediate, put it into rax first
    | mov64 rax, handler
    | call rax
    | postcall 2
    return true;
}

COMPILER(compile_mips_blezl) {
    uintptr_t handler = (uintptr_t)mips_blezl;
    | prepcall2 cpuState, instr
    // x86_64 cannot call a 64 bit immediate, put it into rax first
    | mov64 rax, handler
    | call rax
    | postcall 2
    return true;
}

COMPILER(compile_mips_bne) {
    uintptr_t handler = (uintptr_t)mips_bne;
    | prepcall2 cpuState, instr
    // x86_64 cannot call a 64 bit immediate, put it into rax first
    | mov64 rax, handler
    | call rax
    | postcall 2
    return true;
}

COMPILER(compile_mips_bnel) {
    uintptr_t handler = (uintptr_t)mips_bnel;
    | prepcall2 cpuState, instr
    // x86_64 cannot call a 64 bit immediate, put it into rax first
    | mov64 rax, handler
    | call rax
    | postcall 2
    return true;
}

COMPILER(compile_mips_cache) {
    return false;
}

COMPILER(compile_mips_sb) {
    uintptr_t handler = (uintptr_t)mips_sb;
    | prepcall2 cpuState, instr
    // x86_64 cannot call a 64 bit immediate, put it into rax first
    | mov64 rax, handler
    | call rax
    | postcall 2
    return false;
}

COMPILER(compile_mips_sh) {
    uintptr_t handler = (uintptr_t)mips_sh;
    | prepcall2 cpuState, instr
    // x86_64 cannot call a 64 bit immediate, put it into rax first
    | mov64 rax, handler
    | call rax
    | postcall 2
    return false;
}

COMPILER(compile_mips_sw) {
    uintptr_t handler = (uintptr_t)mips_sw;
    | prepcall2 cpuState, instr
    // x86_64 cannot call a 64 bit immediate, put it into rax first
    | mov64 rax, handler
    | call rax
    | postcall 2
    return false;
}

COMPILER(compile_mips_sd) {
    uintptr_t handler = (uintptr_t)mips_sd;
    | prepcall2 cpuState, instr
    // x86_64 cannot call a 64 bit immediate, put it into rax first
    | mov64 rax, handler
    | call rax
    | postcall 2
    return false;
}

COMPILER(compile_mips_ori) {
    uintptr_t handler = (uintptr_t)mips_ori;
    | prepcall2 cpuState, instr
    // x86_64 cannot call a 64 bit immediate, put it into rax first
    | mov64 rax, handler
    | call rax
    | postcall 2
    return false;
}

COMPILER(compile_mips_j) {
    uintptr_t handler = (uintptr_t)mips_j;
    | prepcall2 cpuState, instr
    // x86_64 cannot call a 64 bit immediate, put it into rax first
    | mov64 rax, handler
    | call rax
    | postcall 2
    return true;
}

COMPILER(compile_mips_jal) {
    uintptr_t handler = (uintptr_t)mips_jal;
    | prepcall2 cpuState, instr
    // x86_64 cannot call a 64 bit immediate, put it into rax first
    | mov64 rax, handler
    | call rax
    | postcall 2
    return true;
}

COMPILER(compile_mips_slti) {
    uintptr_t handler = (uintptr_t)mips_slti;
    | prepcall2 cpuState, instr
    // x86_64 cannot call a 64 bit immediate, put it into rax first
    | mov64 rax, handler
    | call rax
    | postcall 2
    return false;
}

COMPILER(compile_mips_sltiu) {
    uintptr_t handler = (uintptr_t)mips_sltiu;
    | prepcall2 cpuState, instr
    // x86_64 cannot call a 64 bit immediate, put it into rax first
    | mov64 rax, handler
    | call rax
    | postcall 2
    return false;
}

COMPILER(compile_mips_xori) {
    uintptr_t handler = (uintptr_t)mips_xori;
    | prepcall2 cpuState, instr
    // x86_64 cannot call a 64 bit immediate, put it into rax first
    | mov64 rax, handler
    | call rax
    | postcall 2
    return false;
}

COMPILER(compile_mips_daddiu) {
    uintptr_t handler = (uintptr_t)mips_daddiu;
    | prepcall2 cpuState, instr
    // x86_64 cannot call a 64 bit immediate, put it into rax first
    | mov64 rax, handler
    | call rax
    | postcall 2
    return false;
}

COMPILER(compile_mips_lb) {
    uintptr_t handler = (uintptr_t)mips_lb;
    | prepcall2 cpuState, instr
    // x86_64 cannot call a 64 bit immediate, put it into rax first
    | mov64 rax, handler
    | call rax
    | postcall 2
    return false;
}

COMPILER(compile_mips_ldc1) {
    uintptr_t handler = (uintptr_t)mips_ldc1;
    | prepcall2 cpuState, instr
    // x86_64 cannot call a 64 bit immediate, put it into rax first
    | mov64 rax, handler
    | call rax
    | postcall 2
    return false;
}

COMPILER(compile_mips_sdc1) {
    uintptr_t handler = (uintptr_t)mips_sdc1;
    | prepcall2 cpuState, instr
    // x86_64 cannot call a 64 bit immediate, put it into rax first
    | mov64 rax, handler
    | call rax
    | postcall 2
    return false;
}

COMPILER(compile_mips_lwc1) {
    uintptr_t handler = (uintptr_t)mips_lwc1;
    | prepcall2 cpuState, instr
    // x86_64 cannot call a 64 bit immediate, put it into rax first
    | mov64 rax, handler
    | call rax
    | postcall 2
    return false;
}

COMPILER(compile_mips_swc1) {
    uintptr_t handler = (uintptr_t)mips_swc1;
    | prepcall2 cpuState, instr
    // x86_64 cannot call a 64 bit immediate, put it into rax first
    | mov64 rax, handler
    | call rax
    | postcall 2
    return false;
}

COMPILER(compile_mips_lwl) {
    uintptr_t handler = (uintptr_t)mips_lwl;
    | prepcall2 cpuState, instr
    // x86_64 cannot call a 64 bit immediate, put it into rax first
    | mov64 rax, handler
    | call rax
    | postcall 2
    return false;
}

COMPILER(compile_mips_lwr) {
    uintptr_t handler = (uintptr_t)mips_lwr;
    | prepcall2 cpuState, instr
    // x86_64 cannot call a 64 bit immediate, put it into rax first
    | mov64 rax, handler
    | call rax
    | postcall 2
    return false;
}

COMPILER(compile_mips_swl) {
    uintptr_t handler = (uintptr_t)mips_swl;
    | prepcall2 cpuState, instr
    // x86_64 cannot call a 64 bit immediate, put it into rax first
    | mov64 rax, handler
    | call rax
    | postcall 2
    return false;
}

COMPILER(compile_mips_swr) {
    uintptr_t handler = (uintptr_t)mips_swr;
    | prepcall2 cpuState, instr
    // x86_64 cannot call a 64 bit immediate, put it into rax first
    | mov64 rax, handler
    | call rax
    | postcall 2
    return false;
}

COMPILER(compile_mips_ldl) {
    uintptr_t handler = (uintptr_t)mips_ldl;
    | prepcall2 cpuState, instr
    // x86_64 cannot call a 64 bit immediate, put it into rax first
    | mov64 rax, handler
    | call rax
    | postcall 2
    return false;
}

COMPILER(compile_mips_ldr) {
    uintptr_t handler = (uintptr_t)mips_ldr;
    | prepcall2 cpuState, instr
    // x86_64 cannot call a 64 bit immediate, put it into rax first
    | mov64 rax, handler
    | call rax
    | postcall 2
    return false;
}

COMPILER(compile_mips_sdl) {
    uintptr_t handler = (uintptr_t)mips_sdl;
    | prepcall2 cpuState, instr
    // x86_64 cannot call a 64 bit immediate, put it into rax first
    | mov64 rax, handler
    | call rax
    | postcall 2
    return false;
}

COMPILER(compile_mips_sdr) {
    uintptr_t handler = (uintptr_t)mips_sdr;
    | prepcall2 cpuState, instr
    // x86_64 cannot call a 64 bit immediate, put it into rax first
    | mov64 rax, handler
    | call rax
    | postcall 2
    return false;
}

// returns true when the block should end
bool emit_instruction(dasm_State** Dst, mips_instruction_t instr, word address) {
    if (unlikely(instr.raw == 0)) {
        return compile_mips_nop(Dst, instr, address);
    }
    switch (instr.op) {
        case OPC_CP0:    //return r4300i_cp0_decode(pc, instr);
        logfatal("emit cp0");
        case OPC_CP1:    //return r4300i_cp1_decode(pc, instr);
            logfatal("emit cp1");
        case OPC_SPCL:   //return r4300i_special_decode(pc, instr);
            logfatal("emit spcl");
        case OPC_REGIMM: //return r4300i_regimm_decode(pc, instr);
            logfatal("emit regimm");

        case OPC_LD:     return compile_mips_ld(Dst, instr, address);
        case OPC_LUI:    return compile_mips_lui(Dst, instr, address);
        case OPC_ADDIU:  return compile_mips_addiu(Dst, instr, address);
        case OPC_ADDI:   return compile_mips_addi(Dst, instr, address);
        case OPC_DADDI:  return compile_mips_daddi(Dst, instr, address);
        case OPC_ANDI:   return compile_mips_andi(Dst, instr, address);
        case OPC_LBU:    return compile_mips_lbu(Dst, instr, address);
        case OPC_LHU:    return compile_mips_lhu(Dst, instr, address);
        case OPC_LH:     return compile_mips_lh(Dst, instr, address);
        case OPC_LW:     return compile_mips_lw(Dst, instr, address);
        case OPC_LWU:    return compile_mips_lwu(Dst, instr, address);
        case OPC_BEQ:    return compile_mips_beq(Dst, instr, address);
        case OPC_BEQL:   return compile_mips_beql(Dst, instr, address);
        case OPC_BGTZ:   return compile_mips_bgtz(Dst, instr, address);
        case OPC_BGTZL:  return compile_mips_bgtzl(Dst, instr, address);
        case OPC_BLEZ:   return compile_mips_blez(Dst, instr, address);
        case OPC_BLEZL:  return compile_mips_blezl(Dst, instr, address);
        case OPC_BNE:    return compile_mips_bne(Dst, instr, address);
        case OPC_BNEL:   return compile_mips_bnel(Dst, instr, address);
        case OPC_CACHE:  return compile_mips_cache(Dst, instr, address);
        case OPC_SB:     return compile_mips_sb(Dst, instr, address);
        case OPC_SH:     return compile_mips_sh(Dst, instr, address);
        case OPC_SW:     return compile_mips_sw(Dst, instr, address);
        case OPC_SD:     return compile_mips_sd(Dst, instr, address);
        case OPC_ORI:    return compile_mips_ori(Dst, instr, address);
        case OPC_J:      return compile_mips_j(Dst, instr, address);
        case OPC_JAL:    return compile_mips_jal(Dst, instr, address);
        case OPC_SLTI:   return compile_mips_slti(Dst, instr, address);
        case OPC_SLTIU:  return compile_mips_sltiu(Dst, instr, address);
        case OPC_XORI:   return compile_mips_xori(Dst, instr, address);
        case OPC_DADDIU: return compile_mips_daddiu(Dst, instr, address);
        case OPC_LB:     return compile_mips_lb(Dst, instr, address);
        case OPC_LDC1:   return compile_mips_ldc1(Dst, instr, address);
        case OPC_SDC1:   return compile_mips_sdc1(Dst, instr, address);
        case OPC_LWC1:   return compile_mips_lwc1(Dst, instr, address);
        case OPC_SWC1:   return compile_mips_swc1(Dst, instr, address);
        case OPC_LWL:    return compile_mips_lwl(Dst, instr, address);
        case OPC_LWR:    return compile_mips_lwr(Dst, instr, address);
        case OPC_SWL:    return compile_mips_swl(Dst, instr, address);
        case OPC_SWR:    return compile_mips_swr(Dst, instr, address);
        case OPC_LDL:    return compile_mips_ldl(Dst, instr, address);
        case OPC_LDR:    return compile_mips_ldr(Dst, instr, address);
        case OPC_SDL:    return compile_mips_sdl(Dst, instr, address);
        case OPC_SDR:    return compile_mips_sdr(Dst, instr, address);
        default:
#ifdef LOG_ENABLED
            if (n64_log_verbosity < LOG_VERBOSITY_DEBUG) {
                disassemble(pc, instr.raw, buf, 50);
            }
            logfatal("Failed to decode instruction 0x%08X opcode %d%d%d%d%d%d [%s]",
                     instr.raw, instr.op0, instr.op1, instr.op2, instr.op3, instr.op4, instr.op5, buf);
#else
            logfatal("Failed to decode instruction 0x%08X opcode %d%d%d%d%d%d]",
                     instr.raw, instr.op0, instr.op1, instr.op2, instr.op3, instr.op4, instr.op5);
#endif
    }
    uintptr_t handler = (uintptr_t)r4300i_instruction_decode(address, instr);
    | prepcall2 cpuState, instr
    // x86_64 cannot call a 64 bit immediate, put it in rax first
    | mov64 rax, handler
    | call rax
    | postcall 2
    return true;
}

void compile_new_block(n64_dynarec_t* dynarec, r4300i_t* cpu, n64_dynarec_block_t* block, word virtual_address, word physical_address) {

    dasm_State* d;

    |.section code
    dasm_init(&d, DASM_MAXSECTION);

    |.globals lbl_

    void* labels[lbl__MAX];
    dasm_setupglobal(&d, labels, lbl__MAX);

    |.actionlist actions
    dasm_setup(&d, actions);

    mips_instruction_t instr;
    instr.raw = n64_read_physical_word(physical_address);

    |.type cpu_state, r4300i_t, cpuState
    dasm_State** Dst = &d;

    bool should_continue_block = true;
    int block_length = 0;

    |.code
    |->compiled_block:
    | prologue
    do {
        word next_physical_address = physical_address + 4;
        bool instr_ends_block = emit_instruction(Dst, instr, physical_address);
        block_length++;
        bool page_boundary_ends_block = (next_physical_address & (BLOCKCACHE_PAGE_SIZE - 1)) != 0;

        if (instr_ends_block || page_boundary_ends_block) {
            should_continue_block = false;
        }

        physical_address = next_physical_address;
    } while (should_continue_block);
    | epilogue

    void* compiled = link_and_encode(dynarec, &d);
    dasm_free(&d);

    block->start_address = physical_address;
    block->length = block_length;
    block->run = compiled;
}


int n64_dynarec_step(n64_system_t* system, n64_dynarec_t* dynarec) {
    word physical = resolve_virtual_address(system->cpu.pc, &system->cpu.cp0);
    word outer_index = physical >> BLOCKCACHE_OUTER_SHIFT;
    n64_dynarec_block_t* block_list = dynarec->blockcache[outer_index];

    if (block_list == NULL) {
        printf("Need a new block list for page 0x%05X (address 0x%08X virtual 0x%08X)\n", outer_index, physical, system->cpu.pc);
        block_list = bumpalloc_zero(dynarec, BLOCKCACHE_INNER_SIZE * sizeof(n64_dynarec_block_t));
        dynarec->blockcache[outer_index] = block_list;
    }

    word inner_index = (physical & (BLOCKCACHE_PAGE_SIZE - 1)) >> 2;
    //printf("Physical: 0x%08X page: 0x%05X Inner index: %d size: %d\n", physical, outer_index, inner_index, BLOCKCACHE_INNER_SIZE);

    n64_dynarec_block_t* block = &block_list[inner_index];

    if (block->run == NULL) {
        printf("Compilin' new block at 0x%08X / 0x%08X\n", system->cpu.pc, physical);
        compile_new_block(dynarec, &system->cpu, block, system->cpu.pc, physical);
    }

    system->cpu.branch = false;
    system->cpu.prev_pc = system->cpu.pc;
    system->cpu.pc = system->cpu.next_pc;
    system->cpu.next_pc += 4;
    block->run(&system->cpu);

    return block->length * CYCLES_PER_INSTR;
}

n64_dynarec_t* n64_dynarec_init(n64_system_t* system, byte* codecache, size_t codecache_size) {
    printf("Trying to malloc %ld bytes\n", sizeof(n64_dynarec_t));
    n64_dynarec_t* dynarec = calloc(1, sizeof(n64_dynarec_t));

    dynarec->codecache_size = codecache_size;
    dynarec->codecache_used = 0;

    for (int i = 0; i < codecache_size; i++) {
        codecache[i] = 0;
    }

    for (int i = 0; i < BLOCKCACHE_OUTER_SIZE; i++) {
        dynarec->blockcache[i] = 0;
    }

    dynarec->codecache = codecache;
    return dynarec;
}

void invalidate_dynarec_page(n64_dynarec_t* dynarec, word physical_address) {
    word outer_index = physical_address >> BLOCKCACHE_OUTER_SHIFT;
    dynarec->blockcache[outer_index] = NULL;
}
