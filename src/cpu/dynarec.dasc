#include <cpu/dynarec.h>

#include <dynasm/dasm_proto.h>
#include <dynasm/dasm_x86.h>
#include <sys/mman.h>

#include <mem/n64bus.h>
#include "mips_instructions.h"
#include "disassemble.h"
#include "tlb_instructions.h"

//#define N64_LOG_JIT_SYNC_POINTS
//#define N64_LOG_COMPILATIONS

||#if ((defined(_M_X64) || defined(__amd64__)) != X64) || (defined(_WIN32) != WIN)
#error "Wrong DynASM flags used: pass `-D X64` and/or `-D WIN` to dynasm.lua as appropriate"
#endif

static_assert(sizeof(bool) == 1, "sizeof(bool) is expected to be 1!");

|.if X64
|.arch x64
|.else
|.arch x86
|.endif

|.if X64
  |.define cpuState, r12
  |.define instrArg, r13
  |.if WIN
    |.define rArg1, rcx
    |.define rArg2, rdx
  |.else
    |.define rArg1, rdi
    |.define rArg2, rsi
  |.endif
  |.macro prepcall1, arg1
    | mov rArg1, arg1
  |.endmacro
  |.macro prepcall2, arg1, arg2
    | mov rArg1, arg1
    | mov rArg2, arg2
  |.endmacro
  |.define postcall, .nop
    // Called before our block
    |.macro prologue
      // Push callee-saved registers onto the stack so we don't trample them
      | push cpuState
      | push instrArg
      // The CPU's state is passed in as argument 1
      | mov cpuState, rArg1
    |.endmacro
    // Called at the end of our block
    |.macro epilogue
      // Pop callee-saved registers off the stack and then return
      | pop instrArg
      | pop cpuState
      | ret
    |.endmacro
|.endif // TODO x86 version? ARM version?
|.type cpu_state, r4300i_t, cpuState

void flush_code_cache(n64_dynarec_t* dynarec) {
    // Just set the pointer back to the beginning, no need to clear the actual data.
    dynarec->codecache_used = 0;

    // However, the block cache needs to be fully invalidated.
    for (int i = 0; i < BLOCKCACHE_OUTER_SIZE; i++) {
        dynarec->blockcache[i] = NULL;
    }
}

void* bumpalloc(n64_dynarec_t* dynarec, size_t size) {
    if (dynarec->codecache_used + size >= dynarec->codecache_size) {
        flush_code_cache(dynarec);
    }

    void* ptr = &dynarec->codecache[dynarec->codecache_used];

    dynarec->codecache_used += size;

#ifdef N64_LOG_COMPILATIONS
    printf("bumpalloc: %ld used of %ld\n", dynarec->codecache_used, dynarec->codecache_size);
#endif

    return ptr;
}

void* bumpalloc_zero(n64_dynarec_t* dynarec, size_t size) {
    byte* ptr = bumpalloc(dynarec, size);

    for (int i = 0; i < size; i++) {
        ptr[i] = 0;
    }

    return ptr;
}

void* link_and_encode(n64_dynarec_t* dynarec, dasm_State** d) {
    size_t code_size;
    dasm_link(d, &code_size);
#ifdef N64_LOG_COMPILATIONS
    printf("Generated %ld bytes of code\n", code_size);
#endif
    void* buf = bumpalloc(dynarec, code_size);
    dasm_encode(d, buf);

    return buf;
}

INLINE void run_handler(dasm_State** Dst, mips_instruction_t instr, word address, uintptr_t handler) {
    | prepcall2 cpuState, instr
    // x86_64 cannot call a 64 bit immediate, put it into rax first
    | mov64 rax, handler
    | call rax
    | postcall 2
}

INLINE void take_branch(dasm_State** Dst, mips_instruction_t instr, word address) {
    shalf offset = instr.i.immediate;
    sword soffset = offset;
    soffset <<= 2;
    | mov eax, cpu_state->pc
    | add eax, soffset
    | mov cpu_state->next_pc, eax
    | mov al, 1
    | mov cpu_state->branch, al
}

INLINE void load_rax(dasm_State** Dst, word address, int r) {
    uintptr_t src = (uintptr_t) &global_system->cpu.gpr[r];
    | mov64 rax, [src]
}

INLINE void save_rax(dasm_State** Dst, word address, int r) {
    uintptr_t dst = (uintptr_t) &global_system->cpu.gpr[r];
    | mov64 [dst], rax
}

INLINE void sign_extend_eax_rax(dasm_State** Dst) {
    | movsxd rax, eax
}

INLINE void check_exception(dasm_State** Dst, word block_length) {
    // If an exception was triggered, end the block.
    // otherwise, don't end the block.
    | mov al, cpu_state->exception
    // if (cpu_state->exception) {
    | cmp al, 0
    | je >1

    // cpu_state->exception = false
    | mov al, 0
    | mov cpu_state->exception, al

    // return block_length
    | mov eax, block_length
    | epilogue
    // }
    |1:
}


#define TAKEBRANCH take_branch(Dst, instr, address)
#define LOADRAX(r) load_rax(Dst, address, r)
#define SAVERAX(r) save_rax(Dst, address, r)
#define SEAX sign_extend_eax_rax(Dst)
#define RUNHANDLER(handler) run_handler(Dst, instr, address, (uintptr_t)(handler))
#define COMPILER(name) dynarec_instruction_category_t compile_##name(dasm_State** Dst, mips_instruction_t instr, word address, word* extra_cycles)
#define COMP(name, type) COMPILER(name) { RUNHANDLER(name); return type; }
#define BAILZERO(v) do { if ((v) == 0) { return NORMAL; } } while (0)
#define CALL_COMPILER(compiler) compiler(Dst, instr, address, extra_cycles)
#define CASECOMPILE(pattern, compiler) case pattern: return CALL_COMPILER(compiler)

COMPILER(mips_nop) {
    return NORMAL;
}

COMPILER(mips_addi) {
    BAILZERO(instr.i.rt);
    shalf imm = instr.i.immediate;
    sdword ext_imm = imm;
    // This is actually a load-immediate
    if (instr.i.rs == 0) {
        | mov rax, ext_imm
        SAVERAX(instr.i.rt);
    } else {
        LOADRAX(instr.i.rs);
        | add rax, ext_imm
        SEAX;
        SAVERAX(instr.i.rt);
    }
    return NORMAL;
}

COMPILER(mips_addiu) {
    return CALL_COMPILER(compile_mips_addi);
}

dynarec_instruction_category_t compile_mips_beq(dasm_State** Dst, mips_instruction_t instr, word address, word* extra_cycles) {
    // Compile as an unconditional branch
    if (instr.i.rs == 0 && instr.i.rt == 0) {
        // This is a branch-to-self, make it take extra cycles
        if (instr.i.immediate == 0xFFFF) {
            *extra_cycles = 63; // for a total of 64
        }
        TAKEBRANCH;
    } else {
        // handle normally
        RUNHANDLER(mips_beq);
   }
   return BRANCH;
}

COMPILER(mips_cache) {
    return NORMAL;
}

COMPILER(mips_daddi) {
    BAILZERO(instr.i.rt);
    shalf imm = instr.i.immediate;
    sdword ext_imm = imm;
    // This is actually a load-immediate
    if (instr.i.rs == 0) {
        | mov rax, ext_imm
        SAVERAX(instr.i.rt);
    } else {
        LOADRAX(instr.i.rs);
        | add rax, ext_imm
        SAVERAX(instr.i.rt);
    }
    return NORMAL;
}

COMPILER(mips_daddiu) {
    return CALL_COMPILER(compile_mips_daddi);
}

COMPILER(mips_andi) {
    BAILZERO(instr.i.rt);
    LOADRAX(instr.i.rs);
    | and rax, instr.i.immediate
    SAVERAX(instr.i.rt);
    return NORMAL;
}

COMPILER(mips_ori) {
    BAILZERO(instr.i.rt);
    LOADRAX(instr.i.rs);
    | or rax, instr.i.immediate
    SAVERAX(instr.i.rt);
    return NORMAL;
}

COMP(mips_slti, NORMAL);
COMP(mips_sltiu, NORMAL);

COMPILER(mips_xori) {
    BAILZERO(instr.i.rt);
    LOADRAX(instr.i.rs);
    | xor rax, instr.i.immediate
    SAVERAX(instr.i.rt);
    return NORMAL;
}

COMPILER(mips_spc_sll) {
    BAILZERO(instr.r.rd);
    LOADRAX(instr.r.rt);
    | shl eax, instr.r.sa
    SEAX;
    SAVERAX(instr.r.rd);
    return NORMAL;
}

COMPILER(mips_spc_srl) {
    BAILZERO(instr.r.rd);
    LOADRAX(instr.r.rt);
    | shr eax, instr.r.sa
    SEAX;
    SAVERAX(instr.r.rd);
    return NORMAL;
}

COMPILER(mips_spc_sra) {
    BAILZERO(instr.r.rd);
    LOADRAX(instr.r.rt);
    | sar eax, instr.r.sa
    SEAX;
    SAVERAX(instr.r.rd);
    return NORMAL;
}

COMPILER(mips_spc_srav) {
    BAILZERO(instr.r.rd);
    LOADRAX(instr.r.rs);
    | mov rcx, rax
    LOADRAX(instr.r.rt);
    | and cl, 0b11111
    | sar eax, cl
    SEAX;
    SAVERAX(instr.r.rd);
    return NORMAL;
}

COMPILER(mips_spc_sllv) {
    BAILZERO(instr.r.rd);
    LOADRAX(instr.r.rs);
    | mov rcx, rax
    LOADRAX(instr.r.rt);
    | and cl, 0b11111
    | shl eax, cl
    SEAX;
    SAVERAX(instr.r.rd);
    return NORMAL;
}

COMPILER(mips_spc_srlv) {
    BAILZERO(instr.r.rd);
    LOADRAX(instr.r.rs);
    | mov rcx, rax
    LOADRAX(instr.r.rt);
    | and cl, 0b11111
    | shr eax, cl
    SEAX;
    SAVERAX(instr.r.rd);
    return NORMAL;
}

COMPILER(mips_spc_mfhi) {
    BAILZERO(instr.r.rd);
    uintptr_t src = (uintptr_t) &global_system->cpu.mult_hi;
    | mov64 rax, [src]
    SAVERAX(instr.r.rd);
    return NORMAL;
}

COMPILER(mips_spc_mthi) {
    LOADRAX(instr.r.rs);
    uintptr_t dst = (uintptr_t) &global_system->cpu.mult_hi;
    | mov64 [dst], rax
    return NORMAL;
}

COMPILER(mips_spc_mflo) {
    BAILZERO(instr.r.rd);
    uintptr_t src = (uintptr_t) &global_system->cpu.mult_lo;
    | mov64 rax, [src]
    SAVERAX(instr.r.rd);
    return NORMAL;
}

COMPILER(mips_spc_mtlo) {
    LOADRAX(instr.r.rs);
    uintptr_t dst = (uintptr_t) &global_system->cpu.mult_lo;
    | mov64 [dst], rax
    return NORMAL;
}

COMP(mips_spc_dsllv, NORMAL);
COMP(mips_spc_dsrlv, NORMAL);
COMP(mips_spc_mult, NORMAL);
COMP(mips_spc_multu, NORMAL);
COMP(mips_spc_div, NORMAL);
COMP(mips_spc_divu, NORMAL);
COMP(mips_spc_dmult, NORMAL);
COMP(mips_spc_dmultu, NORMAL);
COMP(mips_spc_ddiv, NORMAL);
COMP(mips_spc_ddivu, NORMAL);
COMP(mips_spc_add, NORMAL);
COMP(mips_spc_addu, NORMAL);
COMP(mips_spc_and, NORMAL);
COMP(mips_spc_nor, NORMAL);
COMP(mips_spc_sub, NORMAL);
COMP(mips_spc_subu, NORMAL);
COMP(mips_spc_or, NORMAL);
COMP(mips_spc_xor, NORMAL);
COMP(mips_spc_slt, NORMAL);
COMP(mips_spc_sltu, NORMAL);
COMP(mips_spc_dadd, NORMAL);
COMP(mips_spc_daddu, NORMAL);
COMP(mips_spc_dsubu, NORMAL);
COMP(mips_spc_teq, NORMAL); // TODO this needs to be marked as TRAP and special logic added to the emitted code
COMP(mips_spc_dsll, NORMAL);
COMP(mips_spc_dsrl, NORMAL);
COMP(mips_spc_dsra, NORMAL);
COMP(mips_spc_dsll32, NORMAL);
COMP(mips_spc_dsrl32, NORMAL);
COMP(mips_spc_dsra32, NORMAL);

// Load-stores
COMP(mips_lbu, NORMAL);
COMP(mips_lhu, NORMAL);
COMP(mips_lh, NORMAL);
COMP(mips_lw, NORMAL);
COMP(mips_lwu, NORMAL);
COMP(mips_sb, STORE);
COMP(mips_sh, STORE);
COMP(mips_sw, STORE);
COMP(mips_sd, STORE);
COMP(mips_lb, NORMAL);
COMP(mips_lui, NORMAL);
COMP(mips_ld, NORMAL);
COMP(mips_ldc1, NORMAL);
COMP(mips_sdc1, STORE);
COMP(mips_lwc1, NORMAL);
COMP(mips_swc1, STORE);
COMP(mips_lwl, NORMAL);
COMP(mips_lwr, NORMAL);
COMP(mips_swl, STORE);
COMP(mips_swr, STORE);
COMP(mips_ldl, NORMAL);
COMP(mips_ldr, NORMAL);
COMP(mips_sdl, STORE);
COMP(mips_sdr, STORE);

// Unoptimized branches
COMP(mips_beql, BRANCH_LIKELY);
COMP(mips_bgtz, BRANCH);
COMP(mips_bgtzl, BRANCH_LIKELY);
COMP(mips_blez, BRANCH);
COMP(mips_blezl, BRANCH_LIKELY);
COMP(mips_bne, BRANCH);
COMP(mips_bnel, BRANCH_LIKELY);
COMP(mips_j, BRANCH);
COMP(mips_jal, BRANCH);
COMP(mips_ri_bltz, BRANCH);
COMP(mips_ri_bltzl, BRANCH_LIKELY);
COMP(mips_ri_bltzal, BRANCH);
COMP(mips_ri_bgez, BRANCH);
COMP(mips_ri_bgezl, BRANCH_LIKELY);
COMP(mips_ri_bgezal, BRANCH);
COMP(mips_spc_jr, BRANCH);
COMP(mips_spc_jalr, BRANCH);
COMP(mips_cp_bc1tl, BRANCH_LIKELY);
COMP(mips_cp_bc1fl, BRANCH_LIKELY);

// Instructions that don't make too much sense to optimize
COMP(mips_mfc0, NORMAL);
COMP(mips_mtc0, NORMAL);
COMP(mips_tlbwi, TLB_WRITE);
COMP(mips_tlbp, NORMAL);
COMP(mips_tlbr, NORMAL);
COMP(mips_eret, ERET);


// CP1 stuff
COMP(mips_cfc1, NORMAL);
COMP(mips_mfc1, NORMAL);
COMP(mips_dmfc1, NORMAL);
COMP(mips_mtc1, NORMAL);
COMP(mips_dmtc1, NORMAL);
COMP(mips_ctc1, NORMAL);
COMP(mips_cp_bc1t, BRANCH);
COMP(mips_cp_bc1f, BRANCH);
COMP(mips_cp_add_d, NORMAL);
COMP(mips_cp_add_s, NORMAL);
COMP(mips_cp_sub_d, NORMAL);
COMP(mips_cp_sub_s, NORMAL);
COMP(mips_cp_mul_d, NORMAL);
COMP(mips_cp_mul_s, NORMAL);
COMP(mips_cp_div_d, NORMAL);
COMP(mips_cp_div_s, NORMAL);
COMP(mips_cp_trunc_l_d, NORMAL);
COMP(mips_cp_trunc_l_s, NORMAL);
COMP(mips_cp_trunc_w_d, NORMAL);
COMP(mips_cp_trunc_w_s, NORMAL);
COMP(mips_cp_cvt_d_s, NORMAL);
COMP(mips_cp_cvt_d_w, NORMAL);
COMP(mips_cp_cvt_d_l, NORMAL);
COMP(mips_cp_cvt_l_d, NORMAL);
COMP(mips_cp_cvt_l_s, NORMAL);
COMP(mips_cp_cvt_s_d, NORMAL);
COMP(mips_cp_cvt_s_w, NORMAL);
COMP(mips_cp_cvt_s_l, NORMAL);
COMP(mips_cp_cvt_w_d, NORMAL);
COMP(mips_cp_cvt_w_s, NORMAL);
COMP(mips_cp_sqrt_d, NORMAL);
COMP(mips_cp_sqrt_s, NORMAL);
COMP(mips_cp_abs_d, NORMAL);
COMP(mips_cp_abs_s, NORMAL);
COMP(mips_cp_mov_d, NORMAL);
COMP(mips_cp_mov_s, NORMAL);
COMP(mips_cp_neg_d, NORMAL);
COMP(mips_cp_neg_s, NORMAL);
COMP(mips_cp_c_eq_d, NORMAL);
COMP(mips_cp_c_eq_s, NORMAL);
COMP(mips_cp_c_lt_d, NORMAL);
COMP(mips_cp_c_lt_s, NORMAL);
COMP(mips_cp_c_le_d, NORMAL);
COMP(mips_cp_c_le_s, NORMAL);

dynarec_instruction_category_t compile_cp0_instruction(dasm_State** Dst, mips_instruction_t instr, word address, word* extra_cycles) {
    if (instr.last11 == 0) {
        switch (instr.r.rs) {
            CASECOMPILE(COP_MF, compile_mips_mfc0);
            // Last 11 bits are 0
            CASECOMPILE(COP_MT, compile_mips_mtc0);
            default: {
                char buf[50];
                disassemble(address, instr.raw, buf, 50);
                logfatal("other/unknown MIPS CP0 0x%08X with rs: %d%d%d%d%d [%s]", instr.raw,
                         instr.rs0, instr.rs1, instr.rs2, instr.rs3, instr.rs4, buf);
            }
        }
    } else {
        switch (instr.fr.funct) {
            CASECOMPILE(COP_FUNCT_TLBWI_MULT, compile_mips_tlbwi);
            CASECOMPILE(COP_FUNCT_TLBP,       compile_mips_tlbp);
            CASECOMPILE(COP_FUNCT_TLBR_SUB,   compile_mips_tlbr);
            CASECOMPILE(COP_FUNCT_ERET,       compile_mips_eret);
            default: {
                char buf[50];
                disassemble(address, instr.raw, buf, 50);
                logfatal("other/unknown MIPS CP0 0x%08X with FUNCT: %d%d%d%d%d%d [%s]", instr.raw,
                         instr.funct0, instr.funct1, instr.funct2, instr.funct3, instr.funct4, instr.funct5, buf);
            }
        }
    }
}

INLINE COMPILER(special_instruction) {
    switch (instr.r.funct) {
        CASECOMPILE(FUNCT_SLL, compile_mips_spc_sll);
        CASECOMPILE(FUNCT_SRL, compile_mips_spc_srl);
        CASECOMPILE(FUNCT_SRA, compile_mips_spc_sra);
        CASECOMPILE(FUNCT_SRAV, compile_mips_spc_srav);
        CASECOMPILE(FUNCT_SLLV, compile_mips_spc_sllv);
        CASECOMPILE(FUNCT_SRLV, compile_mips_spc_srlv);
        CASECOMPILE(FUNCT_JR, compile_mips_spc_jr);
        CASECOMPILE(FUNCT_JALR, compile_mips_spc_jalr);
        CASECOMPILE(FUNCT_MFHI, compile_mips_spc_mfhi);
        CASECOMPILE(FUNCT_MTHI, compile_mips_spc_mthi);
        CASECOMPILE(FUNCT_MFLO, compile_mips_spc_mflo);
        CASECOMPILE(FUNCT_MTLO, compile_mips_spc_mtlo);
        CASECOMPILE(FUNCT_DSLLV, compile_mips_spc_dsllv);
        CASECOMPILE(FUNCT_DSRLV, compile_mips_spc_dsrlv);
        CASECOMPILE(FUNCT_MULT, compile_mips_spc_mult);
        CASECOMPILE(FUNCT_MULTU, compile_mips_spc_multu);
        CASECOMPILE(FUNCT_DIV, compile_mips_spc_div);
        CASECOMPILE(FUNCT_DIVU, compile_mips_spc_divu);
        CASECOMPILE(FUNCT_DMULT, compile_mips_spc_dmult);
        CASECOMPILE(FUNCT_DMULTU, compile_mips_spc_dmultu);
        CASECOMPILE(FUNCT_DDIV, compile_mips_spc_ddiv);
        CASECOMPILE(FUNCT_DDIVU, compile_mips_spc_ddivu);
        CASECOMPILE(FUNCT_ADD, compile_mips_spc_add);
        CASECOMPILE(FUNCT_ADDU, compile_mips_spc_addu);
        CASECOMPILE(FUNCT_AND, compile_mips_spc_and);
        CASECOMPILE(FUNCT_NOR, compile_mips_spc_nor);
        CASECOMPILE(FUNCT_SUB, compile_mips_spc_sub);
        CASECOMPILE(FUNCT_SUBU, compile_mips_spc_subu);
        CASECOMPILE(FUNCT_OR, compile_mips_spc_or);
        CASECOMPILE(FUNCT_XOR, compile_mips_spc_xor);
        CASECOMPILE(FUNCT_SLT, compile_mips_spc_slt);
        CASECOMPILE(FUNCT_SLTU, compile_mips_spc_sltu);
        CASECOMPILE(FUNCT_DADD, compile_mips_spc_dadd);
        CASECOMPILE(FUNCT_DADDU, compile_mips_spc_daddu);
        CASECOMPILE(FUNCT_DSUBU, compile_mips_spc_dsubu);
        CASECOMPILE(FUNCT_TEQ, compile_mips_spc_teq);
        CASECOMPILE(FUNCT_DSLL, compile_mips_spc_dsll);
        CASECOMPILE(FUNCT_DSRL, compile_mips_spc_dsrl);
        CASECOMPILE(FUNCT_DSRA, compile_mips_spc_dsra);
        CASECOMPILE(FUNCT_DSLL32, compile_mips_spc_dsll32);
        CASECOMPILE(FUNCT_DSRL32, compile_mips_spc_dsrl32);
        CASECOMPILE(FUNCT_DSRA32, compile_mips_spc_dsra32);
        default: {
            char buf[50];
            disassemble(address, instr.raw, buf, 50);
            logfatal("other/unknown MIPS Special 0x%08X with FUNCT: %d%d%d%d%d%d [%s]", instr.raw,
                     instr.funct0, instr.funct1, instr.funct2, instr.funct3, instr.funct4, instr.funct5, buf);
        }
    }
}

INLINE COMPILER(regimm_instruction) {
    switch (instr.i.rt) {
        CASECOMPILE(RT_BLTZ, compile_mips_ri_bltz);
        CASECOMPILE(RT_BLTZL, compile_mips_ri_bltzl);
        CASECOMPILE(RT_BLTZAL, compile_mips_ri_bltzal);
        CASECOMPILE(RT_BGEZ, compile_mips_ri_bgez);
        CASECOMPILE(RT_BGEZL, compile_mips_ri_bgezl);
        CASECOMPILE(RT_BGEZAL, compile_mips_ri_bgezal);
        default: {
            char buf[50];
            disassemble(address, instr.raw, buf, 50);
            logfatal("other/unknown MIPS REGIMM 0x%08X with RT: %d%d%d%d%d [%s]", instr.raw,
                     instr.rt0, instr.rt1, instr.rt2, instr.rt3, instr.rt4, buf);
        }
    }
}

INLINE COMPILER(cp1_instruction) {
    // This function uses a series of two switch statements.
    // If the instruction doesn't use the RS field for the opcode, then control will fall through to the next
    // switch, and check the FUNCT. It may be worth profiling and seeing if it's faster to check FUNCT first at some point
    switch (instr.r.rs) {
        CASECOMPILE(COP_CF, compile_mips_cfc1);
        CASECOMPILE(COP_MF, compile_mips_mfc1);
        CASECOMPILE(COP_DMF, compile_mips_dmfc1);
        CASECOMPILE(COP_MT, compile_mips_mtc1);
        CASECOMPILE(COP_DMT, compile_mips_dmtc1);
        CASECOMPILE(COP_CT, compile_mips_ctc1);
        case COP_BC:
            switch (instr.r.rt) {
                CASECOMPILE(COP_BC_BCT, compile_mips_cp_bc1t);
                CASECOMPILE(COP_BC_BCF, compile_mips_cp_bc1f);
                CASECOMPILE(COP_BC_BCTL, compile_mips_cp_bc1tl);
                CASECOMPILE(COP_BC_BCFL, compile_mips_cp_bc1fl);
                default: {
                    char buf[50];
                    disassemble(address, instr.raw, buf, 50);
                    logfatal("other/unknown MIPS BC 0x%08X [%s]", instr.raw, buf);
                }
            }
    }
    switch (instr.fr.funct) {
        case COP_FUNCT_ADD:
            switch (instr.fr.fmt) {
                CASECOMPILE(FP_FMT_DOUBLE, compile_mips_cp_add_d);
                CASECOMPILE(FP_FMT_SINGLE, compile_mips_cp_add_s);
                default:
                    logfatal("Undefined!");
            }
        case COP_FUNCT_TLBR_SUB: {
            switch (instr.fr.fmt) {
                CASECOMPILE(FP_FMT_DOUBLE, compile_mips_cp_sub_d);
                CASECOMPILE(FP_FMT_SINGLE, compile_mips_cp_sub_s);
                default:
                    logfatal("Undefined!");
            }
        }
        case COP_FUNCT_TLBWI_MULT:
            switch (instr.fr.fmt) {
                CASECOMPILE(FP_FMT_DOUBLE, compile_mips_cp_mul_d);
                CASECOMPILE(FP_FMT_SINGLE, compile_mips_cp_mul_s);
                default:
                    logfatal("Undefined!");
            }
        case COP_FUNCT_DIV:
            switch (instr.fr.fmt) {
                CASECOMPILE(FP_FMT_DOUBLE, compile_mips_cp_div_d);
                CASECOMPILE(FP_FMT_SINGLE, compile_mips_cp_div_s);
                default:
                    logfatal("Undefined!");
            }
        case COP_FUNCT_TRUNC_L:
            switch (instr.fr.fmt) {
                CASECOMPILE(FP_FMT_DOUBLE, compile_mips_cp_trunc_l_d);
                CASECOMPILE(FP_FMT_SINGLE, compile_mips_cp_trunc_l_s);
                default:
                    logfatal("Undefined!");
            }
        case COP_FUNCT_TRUNC_W:
            switch (instr.fr.fmt) {
                CASECOMPILE(FP_FMT_DOUBLE, compile_mips_cp_trunc_w_d);
                CASECOMPILE(FP_FMT_SINGLE, compile_mips_cp_trunc_w_s);
                default:
                    logfatal("Undefined!");
            }
        case COP_FUNCT_CVT_D:
            switch (instr.fr.fmt) {
                CASECOMPILE(FP_FMT_SINGLE, compile_mips_cp_cvt_d_s);
                CASECOMPILE(FP_FMT_W, compile_mips_cp_cvt_d_w);
                CASECOMPILE(FP_FMT_L, compile_mips_cp_cvt_d_l);
                default:
                    logfatal("Undefined!");
            }
        case COP_FUNCT_CVT_L:
            switch (instr.fr.fmt) {
                CASECOMPILE(FP_FMT_DOUBLE, compile_mips_cp_cvt_l_d);
                CASECOMPILE(FP_FMT_SINGLE, compile_mips_cp_cvt_l_s);
                default:
                    logfatal("Undefined!");
            }
        case COP_FUNCT_CVT_S:
            switch (instr.fr.fmt) {
                CASECOMPILE(FP_FMT_DOUBLE, compile_mips_cp_cvt_s_d);
                CASECOMPILE(FP_FMT_W, compile_mips_cp_cvt_s_w);
                CASECOMPILE(FP_FMT_L, compile_mips_cp_cvt_s_l);
                default:
                    logfatal("Undefined!");
            }
        case COP_FUNCT_CVT_W:
            switch (instr.fr.fmt) {
                CASECOMPILE(FP_FMT_DOUBLE, compile_mips_cp_cvt_w_d);
                CASECOMPILE(FP_FMT_SINGLE, compile_mips_cp_cvt_w_s);
                default:
                    logfatal("Undefined!");
            }
        case COP_FUNCT_SQRT:
            switch (instr.fr.fmt) {
                CASECOMPILE(FP_FMT_DOUBLE, compile_mips_cp_sqrt_d);
                CASECOMPILE(FP_FMT_SINGLE, compile_mips_cp_sqrt_s);
                default:
                    logfatal("Undefined!");
            }

        case COP_FUNCT_ABS:
            switch (instr.fr.fmt) {
                CASECOMPILE(FP_FMT_DOUBLE, compile_mips_cp_abs_d);
                CASECOMPILE(FP_FMT_SINGLE, compile_mips_cp_abs_s);
                default:
                    logfatal("Undefined!");
            }

        case COP_FUNCT_MOV:
            switch (instr.fr.fmt) {
                CASECOMPILE(FP_FMT_DOUBLE, compile_mips_cp_mov_d);
                CASECOMPILE(FP_FMT_SINGLE, compile_mips_cp_mov_s);
                default:
                    logfatal("Undefined!");
            }
        case COP_FUNCT_NEG:
            switch (instr.fr.fmt) {
                CASECOMPILE(FP_FMT_DOUBLE, compile_mips_cp_neg_d);
                CASECOMPILE(FP_FMT_SINGLE, compile_mips_cp_neg_s);
                default:
                    logfatal("Undefined!");
            }
        case COP_FUNCT_C_F:
            logfatal("COP_FUNCT_C_F unimplemented");
        case COP_FUNCT_C_UN:
            logfatal("COP_FUNCT_C_UN unimplemented");
        case COP_FUNCT_C_EQ:
            switch (instr.fr.fmt) {
                CASECOMPILE(FP_FMT_DOUBLE, compile_mips_cp_c_eq_d);
                CASECOMPILE(FP_FMT_SINGLE, compile_mips_cp_c_eq_s);
                default:
                    logfatal("Undefined!");
            }
        case COP_FUNCT_C_UEQ:
            logfatal("COP_FUNCT_C_UEQ unimplemented");
        case COP_FUNCT_C_OLT:
            logfatal("COP_FUNCT_C_OLT unimplemented");
        case COP_FUNCT_C_ULT:
            logfatal("COP_FUNCT_C_ULT unimplemented");
        case COP_FUNCT_C_OLE:
            logfatal("COP_FUNCT_C_OLE unimplemented");
        case COP_FUNCT_C_ULE:
            logfatal("COP_FUNCT_C_ULE unimplemented");
        case COP_FUNCT_C_SF:
            logfatal("COP_FUNCT_C_SF unimplemented");
        case COP_FUNCT_C_NGLE:
            logfatal("COP_FUNCT_C_NGLE unimplemented");
        case COP_FUNCT_C_SEQ:
            logfatal("COP_FUNCT_C_SEQ unimplemented");
        case COP_FUNCT_C_NGL:
            logfatal("COP_FUNCT_C_NGL unimplemented");
        case COP_FUNCT_C_LT:
            switch (instr.fr.fmt) {
                CASECOMPILE(FP_FMT_DOUBLE, compile_mips_cp_c_lt_d);
                CASECOMPILE(FP_FMT_SINGLE, compile_mips_cp_c_lt_s);
                default:
                    logfatal("Undefined!");
            }
        case COP_FUNCT_C_NGE:
            logfatal("COP_FUNCT_C_NGE unimplemented");
        case COP_FUNCT_C_LE:
            switch (instr.fr.fmt) {
                CASECOMPILE(FP_FMT_DOUBLE, compile_mips_cp_c_le_d);
                CASECOMPILE(FP_FMT_SINGLE, compile_mips_cp_c_le_s);
                default:
                    logfatal("Undefined!");
            }
            logfatal("COP_FUNCT_C_LE unimplemented");
        case COP_FUNCT_C_NGT:
            logfatal("COP_FUNCT_C_NGT unimplemented");
    }

    char buf[50];
    disassemble(address, instr.raw, buf, 50);
    logfatal("other/unknown MIPS CP1 0x%08X with rs: %d%d%d%d%d and FUNCT: %d%d%d%d%d%d [%s]", instr.raw,
             instr.rs0, instr.rs1, instr.rs2, instr.rs3, instr.rs4,
             instr.funct0, instr.funct1, instr.funct2, instr.funct3, instr.funct4, instr.funct5, buf);
}
// returns true when the block should end
dynarec_instruction_category_t compile_instruction(dasm_State** Dst, mips_instruction_t instr, word address, word block_length, word* extra_cycles) {
    if (unlikely(instr.raw == 0)) {
        return CALL_COMPILER(compile_mips_nop);
    }
    switch (instr.op) {
        case OPC_CP0:    return CALL_COMPILER(compile_cp0_instruction);
        case OPC_CP1: {
            dynarec_instruction_category_t category = CALL_COMPILER(compile_cp1_instruction);
            check_exception(Dst, block_length);
            return category;
        }
        CASECOMPILE(OPC_SPCL, compile_special_instruction);
        CASECOMPILE(OPC_REGIMM, compile_regimm_instruction);

        CASECOMPILE(OPC_LD, compile_mips_ld);
        CASECOMPILE(OPC_LUI, compile_mips_lui);
        CASECOMPILE(OPC_ADDIU, compile_mips_addiu);
        CASECOMPILE(OPC_ADDI, compile_mips_addi);
        CASECOMPILE(OPC_DADDI, compile_mips_daddi);
        CASECOMPILE(OPC_ANDI, compile_mips_andi);
        CASECOMPILE(OPC_LBU, compile_mips_lbu);
        CASECOMPILE(OPC_LHU, compile_mips_lhu);
        CASECOMPILE(OPC_LH, compile_mips_lh);
        CASECOMPILE(OPC_LW, compile_mips_lw);
        CASECOMPILE(OPC_LWU, compile_mips_lwu);
        CASECOMPILE(OPC_BEQ, compile_mips_beq);
        CASECOMPILE(OPC_BEQL, compile_mips_beql);
        CASECOMPILE(OPC_BGTZ, compile_mips_bgtz);
        CASECOMPILE(OPC_BGTZL, compile_mips_bgtzl);
        CASECOMPILE(OPC_BLEZ, compile_mips_blez);
        CASECOMPILE(OPC_BLEZL, compile_mips_blezl);
        CASECOMPILE(OPC_BNE, compile_mips_bne);
        CASECOMPILE(OPC_BNEL, compile_mips_bnel);
        CASECOMPILE(OPC_CACHE, compile_mips_cache);
        CASECOMPILE(OPC_SB, compile_mips_sb);
        CASECOMPILE(OPC_SH, compile_mips_sh);
        CASECOMPILE(OPC_SW, compile_mips_sw);
        CASECOMPILE(OPC_SD, compile_mips_sd);
        CASECOMPILE(OPC_ORI, compile_mips_ori);
        CASECOMPILE(OPC_J, compile_mips_j);
        CASECOMPILE(OPC_JAL, compile_mips_jal);
        CASECOMPILE(OPC_SLTI, compile_mips_slti);
        CASECOMPILE(OPC_SLTIU, compile_mips_sltiu);
        CASECOMPILE(OPC_XORI, compile_mips_xori);
        CASECOMPILE(OPC_DADDIU, compile_mips_daddiu);
        CASECOMPILE(OPC_LB, compile_mips_lb);
        case OPC_LDC1: {
            dynarec_instruction_category_t category = CALL_COMPILER(compile_mips_ldc1);
            check_exception(Dst, block_length);
            return category;
        }
        case OPC_SDC1: {
            dynarec_instruction_category_t category = CALL_COMPILER(compile_mips_sdc1);
            check_exception(Dst, block_length);
            return category;
        }
        case OPC_LWC1: {
            dynarec_instruction_category_t category = CALL_COMPILER(compile_mips_lwc1);
            check_exception(Dst, block_length);
            return category;
        }
        case OPC_SWC1: {
            dynarec_instruction_category_t category = CALL_COMPILER(compile_mips_swc1);
            check_exception(Dst, block_length);
            return category;
        }
        CASECOMPILE(OPC_LWL, compile_mips_lwl);
        CASECOMPILE(OPC_LWR, compile_mips_lwr);
        CASECOMPILE(OPC_SWL, compile_mips_swl);
        CASECOMPILE(OPC_SWR, compile_mips_swr);
        CASECOMPILE(OPC_LDL, compile_mips_ldl);
        CASECOMPILE(OPC_LDR, compile_mips_ldr);
        CASECOMPILE(OPC_SDL, compile_mips_sdl);
        CASECOMPILE(OPC_SDR, compile_mips_sdr);
        default: {
            char buf[50];
            disassemble(address, instr.raw, buf, 50);
            logfatal("Failed to decode instruction 0x%08X opcode %d%d%d%d%d%d [%s]",
                     instr.raw, instr.op0, instr.op1, instr.op2, instr.op3, instr.op4, instr.op5, buf);
        }
    }
}

void pre_instruction(r4300i_t* cpu, word expected_address) {
    word actual_address = resolve_virtual_address(cpu->pc, &cpu->cp0);
#ifdef N64_LOG_COMPILATIONS
    printf("pc 0x%08X\n", cpu->pc);
#endif
    if (actual_address != expected_address) {
        logfatal("Executing at 0x%08X when we should be at 0x%08X!\n", actual_address, expected_address);
    }
    cpu->branch = false;
    cpu->prev_pc = cpu->pc;
    cpu->pc = cpu->next_pc;
    cpu->next_pc += 4;
}

INLINE void compile_new_block(n64_dynarec_t* dynarec, r4300i_t* compile_time_cpu, n64_dynarec_block_t* block, word virtual_address, word physical_address) {

    dasm_State* d;
    unsigned npc = 8; // number of dynamic labels

    |.section code
    dasm_init(&d, DASM_MAXSECTION);

    |.globals lbl_

    void* labels[lbl__MAX];
    dasm_setupglobal(&d, labels, lbl__MAX);

    |.actionlist actions
    dasm_setup(&d, actions);
    dasm_growpc(&d, npc);

    dasm_State** Dst = &d;

    bool should_continue_block = true;
    int block_length = 0;

    //uintptr_t pre_instruction_ptr = (uintptr_t)pre_instruction;

    int instructions_left_in_block = -1;

    dynarec_instruction_category_t prev_instr_category = NORMAL;

    |.code
    |->compiled_block:
    | prologue
    do {
        mips_instruction_t instr;
        instr.raw = n64_read_physical_word(physical_address);

        word next_physical_address = physical_address + 4;

        /* I'm keeping this around for debugging because pre_instruction() does the actual vs. expected pc check.
        | prepcall2 cpuState, physical_address
        // x86 cannot call a 64 bit immediate, put it into rax first
        | mov64 rax, pre_instruction_ptr
        | call rax
        | postcall 2
         */

        static_assert(sizeof(compile_time_cpu->pc) == 8, "PC must be 64 bits for this to work (using RAX)");
        static_assert(sizeof(compile_time_cpu->next_pc) == 8, "Next PC must be 64 bits for this to work (using RAX)");

        // cpu->branch = false;
        | mov al, 0
        | mov cpu_state->branch, al

        // cpu->prev_pc = cpu->pc;
        | mov rax, cpu_state->pc
        | mov cpu_state->prev_pc, rax

        // cpu->pc = cpu->next_pc;
        | mov rax, cpu_state->next_pc
        | mov cpu_state->pc, rax

        // cpu->next_pc += 4;
        | add rax, 4
        | mov cpu_state->next_pc, rax

        instructions_left_in_block--;
        bool instr_ends_block;

        block_length++; // Needs to happen before we compile since we use the incremented value inside the compiler
        word extra_cycles = 0;
        dynarec_instruction_category_t category = compile_instruction(Dst, instr, physical_address, block_length, &extra_cycles);
        block_length += extra_cycles;

        switch (category) {
            case NORMAL:
                instr_ends_block = instructions_left_in_block == 0;
                break; // the "instructions_left_in_block" check got
            case BRANCH:
                if (prev_instr_category == BRANCH || prev_instr_category == BRANCH_LIKELY) {
                    // Check if the previous branch was taken.

                    // If the last branch wasn't taken, we can treat this the same as if the previous instruction wasn't a branch
                    // just set the cpu->last_branch_taken to cpu->branch_taken and execute the next instruction.

                    // emit:
                    // if (!cpu->last_branch_taken) cpu->last_branch_taken = cpu->branch_taken;
                    logfatal("Branch in a branch delay slot");
                } else {
                    // If the last instruction wasn't a branch, no special behavior is needed. Just set up some state in case the next one is.
                    // emit:
                    // cpu->last_branch_taken = cpu->branch_taken;
                    //logfatal("unimp");
                }

                // If the previous instruction was a branch, exit the block early if

                // If the previous instruction was a branch LIKELY, exit the block early if the _previous branch_
                instr_ends_block = false;
                instructions_left_in_block = 1; // emit delay slot
                break;

            case BRANCH_LIKELY:
                // If the previous instruction was a branch:
                //
                if (prev_instr_category == BRANCH || prev_instr_category == BRANCH_LIKELY) {
                    logfatal("Branch in a branch likely delay slot");
                } else {
                    // If it wasn't taken, end the block.
                    // If it was taken, don't end the block, need to execute delay slot
                    | mov al, cpu_state->branch
                    | cmp al, 0 // if (branch == true)
                    | jne >1
                    | mov rax, block_length
                    | epilogue // return block_length
                    |1:
                }

                instr_ends_block = false;
                instructions_left_in_block = 1; // emit delay slot
                break;
            case ERET:
            case TLB_WRITE:
            case STORE:
                instr_ends_block = true;
                break;

            default:
                logfatal("Unknown dynarec instruction type");
        }

        bool page_boundary_ends_block = (next_physical_address & (BLOCKCACHE_PAGE_SIZE - 1)) == 0;
        // !!!!!!!!!!!!!!! WARNING !!!!!!!!!!!!!!!
        // If the first instruction in the new page is a delay slot, INCLUDE IT IN THE BLOCK ANYWAY.
        // This DOES BREAK a corner case!
        // If the game overwrites the delay slot but does not overwrite the branch or anything in the other page,
        // THIS BLOCK WILL NOT GET MARKED DIRTY.
        // I highly doubt any games do it, but THIS NEEDS TO GET FIXED AT SOME POINT
        // !!!!!!!!!!!!!!! WARNING !!!!!!!!!!!!!!!
        if (instructions_left_in_block == 1) { page_boundary_ends_block = false; } // FIXME, TODO, BAD, EVIL, etc

        if (instr_ends_block || page_boundary_ends_block) {
#ifdef N64_LOG_COMPILATIONS
            printf("Ending block. instr: %d pb: %d (0x%08X)\n", instr_ends_block, page_boundary_ends_block, next_physical_address);
#endif
            should_continue_block = false;
        }

        physical_address = next_physical_address;
        prev_instr_category = category;
    } while (should_continue_block);
    | mov eax, block_length
    | epilogue
    void* compiled = link_and_encode(dynarec, &d);
    dasm_free(&d);

    block->run = compiled;
}


int missing_block_handler(r4300i_t* cpu) {
    word physical = resolve_virtual_address(cpu->pc, &cpu->cp0);
    word outer_index = physical >> BLOCKCACHE_OUTER_SHIFT;
    // TODO: put the dynarec object inside the r4300i_t object to get rid of this need for global_system
    n64_dynarec_block_t* block_list = global_system->dynarec->blockcache[outer_index];
    word inner_index = (physical & (BLOCKCACHE_PAGE_SIZE - 1)) >> 2;

    n64_dynarec_block_t* block = &block_list[inner_index];

#ifdef N64_LOG_COMPILATIONS
    printf("Compilin' new block at 0x%08X / 0x%08X\n", global_system->cpu.pc, physical);
#endif

    compile_new_block(global_system->dynarec, cpu, block, cpu->pc, physical);

    return block->run(cpu);
}

int n64_dynarec_step(n64_system_t* system, n64_dynarec_t* dynarec) {
    word physical = resolve_virtual_address(system->cpu.pc, &system->cpu.cp0);
    word outer_index = physical >> BLOCKCACHE_OUTER_SHIFT;
    n64_dynarec_block_t* block_list = dynarec->blockcache[outer_index];
    word inner_index = (physical & (BLOCKCACHE_PAGE_SIZE - 1)) >> 2;

    if (unlikely(block_list == NULL)) {
#ifdef N64_LOG_COMPILATIONS
        printf("Need a new block list for page 0x%05X (address 0x%08X virtual 0x%08X)\n", outer_index, physical, system->cpu.pc);
#endif
        block_list = bumpalloc_zero(dynarec, BLOCKCACHE_INNER_SIZE * sizeof(n64_dynarec_block_t));
        for (int i = 0; i < BLOCKCACHE_INNER_SIZE; i++) {
            block_list[i].run = missing_block_handler;
        }
        dynarec->blockcache[outer_index] = block_list;
    }

    n64_dynarec_block_t* block = &block_list[inner_index];

    static long total_blocks_run;
    logdebug("Running block at 0x%08X - block run #%ld - block FP: 0x%016lX", system->cpu.pc, ++total_blocks_run, (uintptr_t)block->run);
    int taken = block->run(&system->cpu);
#ifdef N64_LOG_JIT_SYNC_POINTS
    printf("JITSYNC %d %08X ", taken, system->cpu.pc);
    for (int i = 0; i < 32; i++) {
        printf("%016lX", system->cpu.gpr[i]);
        if (i != 31) {
            printf(" ");
        }
    }
    printf("\n");
#endif
    logdebug("Done running block - took %d cycles - pc is now 0x%08X", taken, system->cpu.pc);

    return taken * CYCLES_PER_INSTR;
}

n64_dynarec_t* n64_dynarec_init(n64_system_t* system, byte* codecache, size_t codecache_size) {
#ifdef N64_LOG_COMPILATIONS
    printf("Trying to malloc %ld bytes\n", sizeof(n64_dynarec_t));
#endif
    n64_dynarec_t* dynarec = calloc(1, sizeof(n64_dynarec_t));

    dynarec->codecache_size = codecache_size;
    dynarec->codecache_used = 0;

    for (int i = 0; i < BLOCKCACHE_OUTER_SIZE; i++) {
        dynarec->blockcache[i] = NULL;
    }

    dynarec->codecache = codecache;
    return dynarec;
}

void invalidate_dynarec_page(n64_dynarec_t* dynarec, word physical_address) {
    word outer_index = physical_address >> BLOCKCACHE_OUTER_SHIFT;
    dynarec->blockcache[outer_index] = NULL;
}
