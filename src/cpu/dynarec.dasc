#include <cpu/dynarec.h>

#include <dynasm/dasm_proto.h>
#include <dynasm/dasm_x86.h>
#include <sys/mman.h>

#include <mem/n64bus.h>

||#if ((defined(_M_X64) || defined(__amd64__)) != X64) || (defined(_WIN32) != WIN)
#error "Wrong DynASM flags used: pass `-D X64` and/or `-D WIN` to dynasm.lua as appropriate"
#endif

void* bumpalloc(n64_dynarec_t* dynarec, size_t size) {
    if (dynarec->codecache_used + size >= dynarec->codecache_size) {
        logfatal("Exhausted code cache!");
    }

    void* ptr = &dynarec->codecache[dynarec->codecache_used];

    dynarec->codecache_used += size;

    printf("bumpalloc: %ld used of %ld\n", dynarec->codecache_used, dynarec->codecache_size);

    return ptr;
}

void* bumpalloc_zero(n64_dynarec_t* dynarec, size_t size) {
    byte* ptr = bumpalloc(dynarec, size);

    for (int i = 0; i < size; i++) {
        ptr[i] = 0;
    }

    return ptr;
}

void* link_and_encode(n64_dynarec_t* dynarec, dasm_State** d) {
    size_t code_size;
    dasm_link(d, &code_size);
    printf("Generated %ld bytes of code\n", code_size);
    void* buf = bumpalloc(dynarec, code_size);
    dasm_encode(d, buf);

    return buf;
}

void compile_new_block(n64_dynarec_t* dynarec, r4300i_t* cpu, n64_dynarec_block_t* block, word virtual_address, word physical_address) {

    dasm_State* d;

    |.if X64
    |.arch x64
    |.else
    |.arch x86
    |.endif

    |.section code
    dasm_init(&d, DASM_MAXSECTION);

    |.globals lbl_

    void* labels[lbl__MAX];
    dasm_setupglobal(&d, labels, lbl__MAX);

    |.actionlist actions
    dasm_setup(&d, actions);

    |.if X64
      |.define cpuState, r12
      |.define instrArg, r13
      |.if WIN
        |.define rArg1, rcx
        |.define rArg2, rdx
      |.else
        |.define rArg1, rdi
        |.define rArg2, rsi
      |.endif
      |.macro prepcall2, arg1, arg2
        | mov rArg1, arg1
        | mov rArg2, arg2
      |.endmacro
      |.define postcall, .nop
      // Called before our block
      |.macro prologue
        // Push callee-saved registers onto the stack so we don't trample them
        | push cpuState
        | push instrArg
        | push rax
        // The CPU's state is passed in as argument 1
        | mov cpuState, rArg1
      |.endmacro
      // Called at the end of our block
      |.macro epilogue
        // Pop callee-saved registers off the stack and then return
        | pop rax
        | pop instrArg
        | pop cpuState
        | ret
      |.endmacro
    |.endif // TODO x86 version? ARM version?



    mips_instruction_t instr;
    instr.raw = n64_read_physical_word(physical_address);

    uintptr_t handler = (uintptr_t)r4300i_instruction_decode(cpu, virtual_address, instr);

    |.type cpu_state, r4300i_t, cpuState
    //|.type instruction, mips_instruction_t instr
    dasm_State** Dst = &d;

    |.code
    |->compiled_block:
    | prologue
    | prepcall2 cpuState, instr
    // x86_64 cannot call a 64 bit immediate, put it in rax first
    | mov64 rax, handler
    | call rax
    | postcall 2
    | epilogue

    void* compiled = link_and_encode(dynarec, &d);
    dasm_free(&d);

    block->start_address = virtual_address;
    block->length = 1;
    block->run = compiled;
}

int n64_dynarec_step(n64_system_t* system, n64_dynarec_t* dynarec) {
    word physical = resolve_virtual_address(system->cpu.pc, &system->cpu.cp0);
    word outer_index = physical >> BLOCKCACHE_OUTER_SHIFT;
    n64_dynarec_block_t* block_list = dynarec->blockcache[outer_index];

    if (block_list == NULL) {
        printf("Sizeof block: %ld\n", sizeof(n64_dynarec_block_t));
        block_list = bumpalloc_zero(dynarec, BLOCKCACHE_INNER_SIZE * sizeof(n64_dynarec_block_t));
        dynarec->blockcache[outer_index] = block_list;
    }

    word inner_index = (physical & (BLOCKCACHE_PAGE_SIZE - 1)) >> 2;
    //printf("Physical: 0x%08X page: 0x%05X Inner index: %d size: %d\n", physical, outer_index, inner_index, BLOCKCACHE_INNER_SIZE);

    n64_dynarec_block_t* block = &block_list[inner_index];

    if (block->run == NULL) {
        printf("Compilin' new block at 0x%08X / 0x%08X\n", system->cpu.pc, physical);
        compile_new_block(dynarec, &system->cpu, block, system->cpu.pc, physical);
    } else {
        //printf("Already have a block at 0x%08X / 0x%08X\n", system->cpu.pc, physical);
    }

    //printf("About to run the block... (0x%08X)\n", system->cpu.pc);
    //fflush(stdout);
    system->cpu.branch = false;
    system->cpu.pc = system->cpu.next_pc;
    system->cpu.next_pc += 4;
    block->run(&system->cpu);

    return block->length * CYCLES_PER_INSTR;
}

n64_dynarec_t* n64_dynarec_init(n64_system_t* system, byte* codecache, size_t codecache_size) {
    printf("Trying to malloc %ld bytes\n", sizeof(n64_dynarec_t));
    n64_dynarec_t* dynarec = calloc(1, sizeof(n64_dynarec_t));

    dynarec->codecache_size = codecache_size;
    dynarec->codecache_used = 0;

    for (int i = 0; i < codecache_size; i++) {
        codecache[i] = 0;
    }

    for (int i = 0; i < BLOCKCACHE_OUTER_SIZE; i++) {
        dynarec->blockcache[i] = 0;
    }

    dynarec->codecache = codecache;
    return dynarec;
}

void invalidate_dynarec_page(n64_dynarec_t* dynarec, word physical_address) {
    word outer_index = physical_address >> BLOCKCACHE_OUTER_SHIFT;
    dynarec->blockcache[outer_index] = NULL;
}
